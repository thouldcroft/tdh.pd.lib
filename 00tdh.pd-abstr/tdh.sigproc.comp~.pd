#N canvas 48 23 1158 704 12;
#X obj 20 -130 inlet~;
#X text 15 -198 Source: https://designingsound.org/2013/06/28/tutorial-a-compressor-in-pure-data/
, f 81;
#N canvas 423 77 959 746 peak-gain-computation~ 0;
#X obj 293 178 inlet~;
#X obj 293 217 abs~;
#X text 180 220 Peak detection;
#X obj -30 10 cnv 1 200 1 empty empty Peak\ Gain\ Computation 2 12
0 14 #e0e0e0 #404040 0;
#X obj 293 680 outlet~;
#X text 0 129 • If the signal is above the threshold:;
#X text 0 91 • If the signal is below the thresh:;
#X text 40 148 • output = threshold + (input - threshold)/ratio;
#X text 40 109 • output = input;
#X obj 293 340 -~;
#X floatatom 311 290 5 0 0 1 threshold - -, f 5;
#X text 136 290 input - threshold;
#X floatatom 311 422 5 0 0 1 ratio - -, f 5;
#X text 65 420 (input - threshold) / ratio;
#X obj 260 470 /~;
#X floatatom 311 554 5 0 0 1 threshold - -, f 5;
#X text -16 550 threshold + (input - threshold) / ratio;
#X obj 293 470 *~;
#X text -16 450 * multiply by the INVERSE of the ratio \, instead of
the ratio \, because multiplication is less computationally expensive
(inverse calculated elsewhere), f 42;
#X obj 311 250 r \$0-thresh;
#X obj 311 380 r \$0-ratio;
#X obj 311 520 r \$0-thresh;
#X text -30 66 • Gain Computation for Downward Compression:;
#X text -30 40 • Peak Detection -> Gain Computation -> Gain Computation
/ Peak Detection, f 74;
#X obj 476 430 +~ 0;
#X obj 293 600 +~;
#X obj 293 629 /~;
#X text 271 290 >;
#X text 272 419 >;
#X text 275 549 >;
#X text 260 284 _;
#X text 260 413 _;
#X text 263 543 _;
#X text -40 720 _;
#X text 516 430 This doesn't do anything \, it just makes the patch
neater., f 30;
#X text 930 720 _;
#X obj 600 180 inlet;
#X obj 600 209 switch~;
#X connect 0 0 1 0;
#X connect 1 0 9 0;
#X connect 1 0 24 0;
#X connect 9 0 17 0;
#X connect 10 0 9 1;
#X connect 12 0 17 1;
#X connect 15 0 25 1;
#X connect 17 0 25 0;
#X connect 19 0 10 0;
#X connect 20 0 12 0;
#X connect 21 0 15 0;
#X connect 24 0 26 1;
#X connect 25 0 26 0;
#X connect 26 0 4 0;
#X connect 36 0 37 0;
#X restore 437 220 pd peak-gain-computation~;
#N canvas 296 23 972 750 rms-gain-computation 0;
#X obj 333 -712 inlet~;
#X obj 10 -900 cnv 5 200 1 empty empty RMS\ Gain\ Computation 2 12
0 14 #e0e0e0 #404040 0;
#X obj 333 -160 outlet~;
#X text 40 -781 • If the signal is above the threshold:;
#X text 40 -819 • If the signal is below the thresh:;
#X text 80 -762 • output = threshold + (input - threshold)/ratio
;
#X text 80 -801 • output = input;
#X obj 333 -500 -~;
#X floatatom 351 -550 5 0 0 1 threshold - -, f 5;
#X text 176 -550 input - threshold;
#X floatatom 351 -418 5 0 0 1 ratio - -, f 5;
#X text 105 -420 (input - threshold) / ratio;
#X obj 300 -370 /~;
#X floatatom 351 -286 5 0 0 1 threshold - -, f 5;
#X text 24 -290 threshold + (input - threshold) / ratio;
#X obj 333 -370 *~;
#X text 24 -390 * multiply by the INVERSE of the ratio \, instead of
the ratio \, because multiplication is less computationally expensive
(inverse calculated elsewhere), f 42;
#X obj 351 -590 r \$0-thresh;
#X obj 351 -460 r \$0-ratio;
#X obj 351 -320 r \$0-thresh;
#X text 10 -844 • Gain Computation for Downward Compression:;
#X obj 516 -410 +~ 0;
#X obj 333 -240 +~;
#X obj 333 -211 /~;
#X text 311 -550 >;
#X text 312 -421 >;
#X text 315 -291 >;
#X text 300 -556 _;
#X text 300 -427 _;
#X text 303 -297 _;
#X text 0 -120 _;
#X text 556 -410 This doesn't do anything \, it just makes the patch
neater., f 30;
#X text 970 -120 _;
#X obj 333 -670 env~ 512;
#X text 113 -670 calculate the RMS value in dB;
#X obj 333 -637 dbtorms~;
#X text 116 -637 rms value in linear amp;
#X text 970 -960 _;
#X text 10 -870 • RMS Value -> Gain Computation -> Gain Computation
/ RMS Value, f 74;
#X obj 540 -709 inlet;
#X obj 540 -680 switch~;
#X connect 0 0 33 0;
#X connect 7 0 15 0;
#X connect 8 0 7 1;
#X connect 10 0 15 1;
#X connect 13 0 22 1;
#X connect 15 0 22 0;
#X connect 17 0 8 0;
#X connect 18 0 10 0;
#X connect 19 0 13 0;
#X connect 21 0 23 1;
#X connect 22 0 23 0;
#X connect 23 0 2 0;
#X connect 33 0 35 0;
#X connect 35 0 7 0;
#X connect 35 0 21 0;
#X connect 39 0 40 0;
#X restore 237 220 pd rms-gain-computation;
#X obj 237 330 clip~ 0 1;
#X text 310 310 prevents the compressor from gaining the signal positively
when the threshold is at 0;
#X obj 237 400 lop~;
#X text 364 360 Using a lowpass filter as a ramp generator \, converting
time in ms to frequency (f = 1000 / time) (calculation done elsewhere)
;
#N canvas 0 22 450 300 delwrite 0;
#X obj 40 91 inlet~;
#X obj 40 120 delwrite~ \$0-comp 500;
#X obj 43 174 outlet~;
#X text 30 -10 Pd can't employ a delay less than a block size (1.4ms
typically) \, unless you encapsulate [delwrite~] and [delread~] in
subpatches \, give each a dummy [outlet~] and [inlet~] and connect
them. THIS WAS A BRAND NEW TOPIC TO ME!!;
#X connect 0 0 1 0;
#X restore 20 190 pd delwrite;
#N canvas 0 22 450 300 delread 0;
#X obj 20 111 inlet~;
#X obj 20 180 outlet~;
#X text 10 10 Pd can't employ a delay less than a block size (1.4ms
typically) \, unless you encapsulate [delwrite~] and [delread~] in
subpatches \, give each a dummy [outlet~] and [inlet~] and connect
them. THIS WAS A BRAND NEW TOPIC TO ME!!;
#X obj 20 150 delread~ \$0-comp 0;
#X obj 160 110 inlet;
#X connect 3 0 1 0;
#X connect 4 0 3 0;
#X restore 20 280 pd delread;
#X text 60 160 lookahead;
#X floatatom 87 252 5 0 0 1 lookahead_time - -, f 5;
#X obj 219 500 *~;
#X text 240 190 RMS Gain Computation;
#X text 440 190 Peak Gain Computation;
#X obj 219 609 *~;
#X obj 260 470 r \$0-makeup;
#X obj 260 529 pack f 5;
#X obj 260 558 line~;
#X obj 219 638 outlet~;
#X obj 395 99 t f f;
#X obj 395 128 == 0;
#X obj 90 -130 inlet thresh;
#X obj 230 -130 inlet ratio;
#X obj 360 -130 inlet attRel;
#X obj 262 360 r \$0-att-rel;
#X obj 500 -130 inlet makeup;
#X obj 640 -130 inlet rmsPeakSw;
#X obj 90 -72 s \$0-thresh;
#N canvas 634 97 450 300 dbFStodBlin 0;
#X obj 60 50 inlet;
#X obj 60 80 + 100;
#X obj 60 110 dbtorms;
#X obj 60 140 outlet;
#X text 110 80 convert dBFS (-100 to 0) to dBPD (0 to 100);
#X text 120 110 convert dBPD to dBlin ("0.0 to 1.0");
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 3 0;
#X restore 90 -101 pd dbFStodBlin;
#N canvas 0 22 450 300 inverse 0;
#X obj 54 43 inlet;
#X obj 54 72 swap 1;
#X obj 54 101 /;
#X obj 54 130 outlet;
#X text 100 100 Produces 1/ratio;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 1 1 2 1;
#X connect 2 0 3 0;
#X restore 230 -101 pd inverse;
#X obj 230 -72 s \$0-ratio;
#N canvas 0 22 450 300 mstofreq 0;
#X obj 70 30 inlet;
#X obj 70 59 swap 1000;
#X obj 70 88 /;
#X obj 70 117 outlet;
#X text 120 90 Produces 1000/time in ms;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 1 1 2 1;
#X connect 2 0 3 0;
#X restore 360 -101 pd mstofreq;
#X obj 360 -72 s \$0-att-rel;
#N canvas 634 97 450 300 dbFStodBlin 0;
#X obj 60 50 inlet;
#X obj 60 80 + 100;
#X obj 60 110 dbtorms;
#X obj 60 140 outlet;
#X text 110 80 convert dBFS (-100 to 0) to dBPD (0 to 100);
#X text 120 110 convert dBPD to dBlin ("0.0 to 1.0");
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 3 0;
#X restore 500 -100 pd dbFStodBlin;
#X obj 500 -70 s \$0-makeup;
#X obj 395 70 r \$0-rmsPeakSw;
#X obj 640 -100 s \$0-rmsPeakSw;
#X obj 800 -101 s \$0-lookahead;
#X obj 800 -130 inlet lookahead;
#X obj 87 223 r \$0-lookahead;
#X floatatom 260 500 5 0 0 1 makeup - -, f 5;
#X obj 840 -180 loadbang;
#X msg 920 -130;
#X msg 460 -130;
#X msg 190 -130;
#X msg 320 -130;
#X msg 920 -130 0;
#X msg 760 -130 0;
#X msg 600 -130 40;
#X connect 0 0 2 0;
#X connect 0 0 3 0;
#X connect 0 0 8 0;
#X connect 2 0 4 0;
#X connect 3 0 4 0;
#X connect 4 0 6 0;
#X connect 6 0 12 1;
#X connect 8 0 9 0;
#X connect 9 0 12 0;
#X connect 11 0 9 1;
#X connect 12 0 15 0;
#X connect 15 0 19 0;
#X connect 16 0 41 0;
#X connect 17 0 18 0;
#X connect 18 0 15 1;
#X connect 20 0 21 0;
#X connect 20 1 2 1;
#X connect 21 0 3 1;
#X connect 22 0 29 0;
#X connect 23 0 30 0;
#X connect 24 0 32 0;
#X connect 25 0 6 1;
#X connect 26 0 34 0;
#X connect 27 0 37 0;
#X connect 29 0 28 0;
#X connect 30 0 31 0;
#X connect 32 0 33 0;
#X connect 34 0 35 0;
#X connect 36 0 20 0;
#X connect 39 0 38 0;
#X connect 40 0 11 0;
#X connect 41 0 17 0;
